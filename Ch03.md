# 1. Machine-Level Representation of Program

## 1.1. Machine-Level Code

Several features about machine code and its disassembled representation are worth noting:

- x86-64 instructions can range in length from 1 to 15 bytes.
- The instruction format is designed in such a way that from a given starting position.

## 1.2. Data Formats

![data_types_in_x86-64.png](./images/data_types_in_x86-64.png)

## 1.3. Accessing Information

![registers.png](./images/registers.png)

### 1.3.1. Operand Specifiers

![operand_forms.png](./images/operand_forms.png)

### 1.3.2. Data Movement Instructions

![movement_instructions.png](.\images\movement_instructions.png)

- x86-64 imposesthe restriction that a move instruction cannot have both operands refer to **memory locations**.

- Immediate **source** operands can be represented as 32-bit two's-complement numbers in `movq`.

- **Memory reference** in x86-64 are always given with quad word registers, such as `%rax`,even if the operand is a byte, single word, or double word.

![movement_instructions_zero-extending.png](.\images\movement_instructions_zero-extending.png)

![movement_instructions_sign-extending.png](.\images\movement_instructions_sign-extending.png)

### Pushing and Popping Stack Data

![push_and_pop_instructions.png](.\images\push_and_pop_instructions.png)

![illustration_of_stack_operation.png](./images/illustration_of_stack_operation.png)

## Arithmetic and Logical Operations

![integer_arithmetic_operations.png](./images/integer_arithmetic_operations.png)